SNAPSHOT v0.2 — Castra (VM orchestration harness)

Project promise
- Orchestrate multiple virtual machines on a single host for agent workloads.
- QEMU is the sole virtualization backend (initially).
- The host acts as the primary communication channel for agents interacting with VMs.
- UX is at a premium: fast, legible, low-friction CLI with sensible defaults and clear status.

Current code state (observable surfaces)
- Rust crate "castra" with a clap-based CLI binary.
  - Subcommands scaffolded: init, up, down, status, ports, logs.
  - `--config PATH` supported; discovery searches upward for castra.toml unless `--skip-discovery` on relevant commands.
  - Helpful errors and exit codes: help/version exit 0; usage errors exit 64; NYI surfaces return structured error with a tracking hint.
  - `init` implemented: writes castra.toml (TOML) and creates .castra/ workdir with friendly next-steps copy.
  - Default config content includes single VM (devbox), overlay path, basic port forwards, and a placeholder workflow.
- Not-yet-implemented commands (`up`, `down`, `status`, `ports`, `logs`) return NYI with a tracking path that currently points to .vizier/* TODOs (note: repository stores TODOs at project root).

Near-term user-facing surface (target)
- A single binary: `castra`.
- Core flows to support (single-VM first):
  1) `castra init` — scaffold config and working directories. [DONE in code]
  2) `castra up` — start defined VM(s) via QEMU. [NYI]
  3) `castra status` — show per-VM lifecycle and comm health. [NYI]
  4) `castra down` — graceful stop/cleanup. [NYI]
  5) `castra ports|logs` — connectivity and recent activity. [NYI]
- Configuration: TOML at repo root (castra.toml); auto-discovered or overridden via --config.

External constraints and promises
- Backend: QEMU only (no libvirt requirement in UX; implementation choices remain open).
- Communication: Host-centric broker model; concrete protocol remains open.
- Defaults should be safe and ergonomic: ephemeral overlays, NAT + host port mappings, clear teardown.

Active threads (narrative arcs)
1) UX-first CLI contract
   - Tension: We promised polished CLI; skeleton now exists with subcommands, help/version, and structured errors. Remaining: refine copy, ensure NYI tracking hints reference real paths.
   - Depends on: CODE STATE v0.2 CLI; External promise: UX premium.
   - Outcome: Predictable commands, helpful output, meaningful exit codes.

2) QEMU backend and VM lifecycle
   - Tension: QEMU orchestration unimplemented.
   - Depends on: External constraint: QEMU backend.
   - Outcome: Start/stop VM reliably; detect boot success; tear down cleanly.

3) Host communication channel
   - Tension: No broker yet.
   - Depends on: Host-centric comms promise.
   - Outcome: Host listener/broker exists; stable agent↔VM path.

4) Project configuration and discovery
   - Tension: Init and discovery now implemented; config validation and friendly errors still missing.
   - Outcome: Readable config defines VMs/resources; auto-discovered from project root with clear diagnostics.

5) VM images and storage hygiene
   - Tension: Need safe image/overlay flows.
   - Outcome: Base images + ephemeral overlays by default; explicit cleanup commands.

6) Networking and connectivity ergonomics
   - Tension: Need predictable host/guest connectivity; `ports` UX TBD.
   - Outcome: NAT with stable forwards; clear `ports` view; common host OSes work.

7) Observability and status legibility
   - Tension: Status/logs surfaces are NYI; copy and states TBD.
   - Outcome: `status`/`logs` provide clear, color-coded info.

8) Safety and resource limits
   - Tension: Preflight checks and limits not implemented.
   - Outcome: Configurable CPU/mem; preflight; graceful shutdown.

9) Toolchain baseline and distribution
   - Tension: Toolchain packaging and releases TBD.
   - Outcome: Stable toolchain target; `cargo install`/releases; `--version` surfaced (commit optional).

Direction of travel
- Build on the working CLI: next, deliver a minimal end-to-end run (single VM): up → status → down. Fix NYI tracking paths to match repository layout. Keep UX copy crisp and errors actionable.