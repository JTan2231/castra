SNAPSHOT v0.6 — Castra (VM orchestration harness)

Project promise
- Orchestrate multiple virtual machines on a single host for agent workloads.
- QEMU is the sole virtualization backend (initially).
- The host acts as the primary communication channel for agents interacting with VMs.
- UX is at a premium: fast, legible, low-friction CLI with sensible defaults and clear status.

Current code state (observable surfaces)
- Rust CLI binary (clap).
  - Subcommands: init, up, down, status, ports, logs; hidden broker.
  - Global: --config PATH; discovery searches upward for castra.toml; --skip-discovery honored on up/down/status. Empty invocation prints help and exits 64. Help/version exit 0.
  - Exit codes: usage 64; config/path 66; parse/invalid 65; IO/launch/shutdown/preflight 70–74 via CliError.exit_code.
  - init: writes castra.toml and .castra/ workdir scaffold with next-steps copy.
  - ports: loads config, prints warning summary, detects duplicate host ports and broker-port collision; prints declared forwards table; --verbose prints per-VM details and workflow steps.
  - up:
    • Resolves config; prints warning summary.
    • Preflight: host CPU/memory headroom (with warn/fail thresholds), free-disk checks for state/logs/overlay dirs, host port conflict checks (including broker), qemu-system presence; --force bypass for fail conditions (warns).
    • Ensures per-VM overlay (via qemu-img when available; otherwise prints manual command).
    • Starts host broker (hidden broker subcommand) writing .castra/broker.pid and logs to .castra/logs/broker.log; idempotent if already running.
    • Launches each VM via qemu-system (hvf on macOS, kvm on Linux) with user-mode NAT and hostfwd rules; writes .castra/<vm>.pid; logs QEMU stdout/stderr to .castra/logs/<vm>.log and serial to <vm>-serial.log.
  - status: prints table (VM | STATE | CPU/MEM | UPTIME | BROKER | FORWARDS); colors on TTY only. STATE derived from pidfile/process checks; UPTIME from pidfile mtime. BROKER column shows waiting when broker listening, offline otherwise.
  - down: reads pidfiles; sends SIGTERM then escalates SIGKILL with timeouts; removes pidfiles; stops broker similarly; prints progress.
  - logs: tails broker and per-VM qemu/serial files; prefixes [host-broker] | [vm:<name>:qemu] | [vm:<name>:serial]; respects --tail N and --follow with graceful gaps.
- Configuration: TOML; required fields validated; unknown fields warned with path context; relative paths resolved against config dir. Default broker.port = 7070. Warning summary emitted once per command with next-steps hints.

Narrative state (active themes and tensions)
1) UX-first CLI contract
   - Promise: predictable commands, crisp copy, consistent exit codes.
   - State: Help and copy largely aligned; exit policy consistent. Keep per-command help synced as features evolve.

2) QEMU backend and VM lifecycle
   - Promise: reliable start/stop; guest-cooperative shutdown.
   - State: Start/stop implemented with TERM→KILL; ACPI-first path not yet wired; no QMP.

3) Host communication channel
   - Promise: broker reachable; surface guest reachability.
   - State: Broker listener implemented with line-based greeting and logging; status shows listening vs offline; no guest handshake yet to mark reachable.

4) Project configuration and discovery
   - Promise: readable config with actionable diagnostics.
   - State: Parser validates with warnings; warning summary and next-steps in place; discovery and --config implemented.

5) VM images and storage hygiene
   - Promise: safe, predictable storage layout.
   - State: Overlays created as needed; runtime and logs live under .castra (logs at .castra/logs, pidfiles at .castra/); potential split into run/ vs logs/ remains open.

6) Networking and connectivity ergonomics
   - Promise: predictable NAT + forwards; clarity on declared vs active.
   - State: NAT + hostfwd on launch; ports lists declared forwards and flags conflicts and broker reservation; runtime inspection of active forwards not yet.

7) Observability and status legibility
   - Promise: legible status and logs with color-on-tty.
   - State: Status and logs implemented per copy; BROKER shows waiting/offline; width calcs avoid ragged columns; truncation/long-name handling minimal but acceptable.

8) Safety and resource limits
   - Promise: avoid host overload, provide overrides with care.
   - State: CPU/mem/disk/port preflight implemented with thresholds, friendly messages, and --force escape hatch. Signals inside castra not yet wired for graceful self-termination; relies on child process management.

9) Toolchain baseline and distribution
   - Promise: surface git SHA; document MSRV and release path.
   - State: --version uses Cargo semver only; git SHA/MSRV/releasing docs still TBD.

10) Seamless Alpine Bootstrap (new)
   - Promise: zero-config `castra up` boots a managed Alpine VM; built-in catalog drives asset fetch/transform; clear progress; compatible with user-provided QCOWs.
   - State: Not implemented. Plan adopted to add a managed image catalog, ImageManager pipeline with cache/manifest, config fallback to an in-memory project using the Alpine profile, and QEMU profile injection for kernel/args. UX requires progress lines and cache-hit messages; detailed logs under .castra/logs.

Direction of travel
- Implement Seamless Alpine Bootstrap in phases: (1) catalog + config model + manager skeleton; (2) fallback project + manager wiring in up/status; (3) QEMU profile injection and direct kernel boot; (4) CLI copy + docs/tests. Maintain copy/exit-code discipline and keep warning/observability polish high. Continue hardening lifecycle (ACPI/QMP) afterwards, ensuring compatibility with managed-image flow.