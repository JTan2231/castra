SNAPSHOT v0.4 — Castra (VM orchestration harness)

Project promise
- Orchestrate multiple virtual machines on a single host for agent workloads.
- QEMU is the sole virtualization backend (initially).
- The host acts as the primary communication channel for agents interacting with VMs.
- UX is at a premium: fast, legible, low-friction CLI with sensible defaults and clear status.

Current code state (observable surfaces)
- Rust crate "castra" with a clap-based CLI binary.
  - Subcommands: init, up, down, status, ports, logs; hidden broker used internally.
  - `--config PATH` supported; discovery searches upward for castra.toml unless `--skip-discovery` (up/down/status honor it).
  - Exit codes: help/version exit 0; usage errors exit 64; other failures mapped via CliError to 65–74.
  - `init`: writes castra.toml and creates .castra/ workdir with next-steps copy.
  - `ports`: loads config, emits parser warnings, detects port conflicts (including broker-port collision), prints tabular declared forwards; `--verbose` shows per-VM details and workflow steps.
  - `up`:
    • Resolves config; prints parse warnings.
    • Preflight: detects duplicate/overlapping ports; checks runtime availability (bind test) for each host forward and broker port; verifies qemu-system presence; prepares state/log directories; ensures overlays (creates via qemu-img if available, otherwise prints manual command).
    • Starts host broker subprocess (hidden `broker` command) writing .castra/broker.pid and logs to .castra/logs/broker.log; idempotent if already running.
    • Launches each VM via qemu-system with user-mode NAT and hostfwd rules; writes per-VM pidfile (.castra/<vm>.pid); logs QEMU stdout/stderr to .castra/logs/<vm>.log and serial to .castra/logs/<vm>-serial.log.
  - `status`: prints table (VM | STATE | CPU/MEM | UPTIME | BROKER | FORWARDS); colors on TTY, plain when redirected. STATE is derived from pidfile/process checks; UPTIME from pidfile mtime. BROKER shows waiting/offline (reachable TBD).
  - `down`: for each VM pidfile, sends SIGTERM, waits, escalates SIGKILL, removes pidfile; also stops the broker similarly; prints progress summaries.
  - `logs`: shows tail per source and optional `--follow` streaming for [host-broker], vm:<name>:qemu, vm:<name>:serial; degrades gracefully if a file is not yet present.
- Configuration: TOML at repo root (castra.toml); auto-discovered or overridden via --config. Parser validates required fields, resolves relative paths against config directory, and accumulates non-fatal warnings for unknown fields and patterns (e.g., duplicate guest forwards per VM). Default broker.port = 7070.

Near-term user-facing surface (target)
- End-to-end minimal flow is live for multi-VM configs: init → ports → up → status/logs → down.
- Refinements planned:
  1) ACPI-first shutdown path before TERM/KILL.
  2) Distinguish active vs planned forwards (QMP/runtime inspection) and possible `ports --active`.
  3) Broker reachability signal from guest handshake (status: reachable vs waiting).
  4) Warning summary block post-parse; strengthen copy/examples in `--help`.
  5) Optional directory layout split: .castra/run (pidfiles/sockets) vs .castra/logs.

External constraints and promises
- Backend: QEMU only; macOS uses HVF, Linux uses KVM; `-cpu host` requested.
- Communication: Host-centric broker model; current protocol is minimal line-based greeting for connectivity validation.
- Defaults emphasize safety: overlay images over base; NAT networking; clear teardown with `down`.

Active threads (narrative arcs)
1) UX-first CLI contract
   - Tension: Keep help/copy precise and exit-code policy consistent as features land.
   - Depends on: Implemented CLI commands and current outputs.
   - Outcome: Predictable commands, accurate help text, examples.

2) QEMU backend and VM lifecycle
   - Tension: Improve shutdown via ACPI; introduce QMP for richer lifecycle.
   - Depends on: Current direct qemu-system invocation with pidfiles and logs.
   - Outcome: Reliable start/stop with cleaner guest-cooperative shutdown.

3) Host communication channel
   - Tension: Broker running and logged; need guest handshake to surface "reachable".
   - Depends on: Hidden broker subcommand, status integration.
   - Outcome: Clear broker health and guest reachability status.

4) Project configuration and discovery
   - Tension: Parser warnings shown verbosely; add summary and next-steps hints.
   - Depends on: Validating parser and warning collection.
   - Outcome: Readable diagnostics with actionable suggestions.

5) VM images and storage hygiene
   - Tension: Overlays created inline; directory layout could separate run vs logs vs images more clearly.
   - Outcome: Safer, predictable storage with cleanup affordances.

6) Networking and connectivity ergonomics
   - Tension: Active forwards not yet distinguished at runtime; conflicts/broker overlap handled.
   - Outcome: NAT with stable forwards; future `--active` view.

7) Observability and status legibility
   - Tension: Status lacks broker "reachable" and may need width/truncation handling for long names.
   - Outcome: Color-coded, legible status and resilient logs streaming.

8) Safety and resource limits
   - Tension: Preflight lacks disk/CPU/mem headroom checks; signals not yet translated into graceful orchestrator shutdown.
   - Outcome: Headroom checks with `--force` escape hatch; graceful signal handling.

9) Toolchain baseline and distribution
   - Tension: Git SHA in --version and release docs remain TBD.
   - Outcome: Version string includes git short SHA when available; MSRV and releasing checklist documented.

Direction of travel
- Harden the MVP by adding ACPI-first shutdown, warning summaries, and broker reachability handshake. Then introduce runtime inspection (QMP) to separate active vs planned forwards and consider a .castra/run layout to declutter logs. Keep UX copy crisp; maintain exit-code consistency.