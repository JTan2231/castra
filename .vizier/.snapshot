SNAPSHOT v0.3 — Castra (VM orchestration harness)

Project promise
- Orchestrate multiple virtual machines on a single host for agent workloads.
- QEMU is the sole virtualization backend (initially).
- The host acts as the primary communication channel for agents interacting with VMs.
- UX is at a premium: fast, legible, low-friction CLI with sensible defaults and clear status.

Current code state (observable surfaces)
- Rust crate "castra" with a clap-based CLI binary.
  - Subcommands: init, up, down, status, ports, logs.
  - `--config PATH` supported; discovery searches upward for castra.toml unless `--skip-discovery` on relevant commands.
  - Helpful errors and exit codes: help/version exit 0; usage errors exit 64; NYI surfaces return structured error with a tracking hint that references repo-local TODO files.
  - `init` implemented: writes castra.toml (TOML) and creates .castra/ workdir with friendly next-steps copy.
  - `ports` implemented: loads config, emits warnings for unknown fields, detects port conflicts (including broker port collision), and prints a tabular summary; `--verbose` adds per-VM detail and workflow steps.
  - `up`, `down`, `status`, `logs` currently NYI.
  - CLI long_about now references repo-root todo_*.md files (previous .vizier reference removed).
- Configuration: TOML at repo root (castra.toml); auto-discovered or overridden via --config. Parser performs validation with actionable errors and accumulates non-fatal warnings for unknown fields and suspicious patterns.

Near-term user-facing surface (target)
- A single binary: `castra`.
- Core flows to support (single-VM first):
  1) `castra init` — scaffold config and working directories. [DONE]
  2) `castra ports` — show declared/active connectivity and conflicts. [DONE v1]
  3) `castra up` — start defined VM(s) via QEMU. [NYI]
  4) `castra status` — show per-VM lifecycle and comm health. [NYI]
  5) `castra down` — graceful stop/cleanup. [NYI]
  6) `castra logs` — connectivity and recent activity. [NYI]
- Configuration: TOML with version, [project], [[vms]] (name, description?, base_image, overlay, cpus, memory, [[vms.port_forwards]] host/guest/protocol), [workflows] (init[]), [broker] (port). Relative paths resolved against config directory.

External constraints and promises
- Backend: QEMU only (no libvirt requirement in UX; implementation choices remain open).
- Communication: Host-centric broker model; concrete protocol remains open.
- Defaults should be safe and ergonomic: ephemeral overlays, NAT + host port mappings, clear teardown.

Active threads (narrative arcs)
1) UX-first CLI contract
   - Tension: We promised polished CLI; skeleton exists with subcommands, help/version, and structured errors. Prior mismatch in NYI tracking hints/long_about is resolved; copy now points to repo-root todo_*.md files.
   - Depends on: CODE STATE v0.3 CLI; External promise: UX premium.
   - Outcome: Predictable commands, helpful output, meaningful exit codes.

2) QEMU backend and VM lifecycle
   - Tension: QEMU orchestration unimplemented.
   - Depends on: External constraint: QEMU backend.
   - Outcome: Start/stop VM reliably; detect boot success; tear down cleanly.

3) Host communication channel
   - Tension: No broker yet.
   - Depends on: Host-centric comms promise.
   - Outcome: Host listener/broker exists; stable agent↔VM path.

4) Project configuration and discovery
   - Tension: Init and discovery implemented; parser now performs validation, resolves relative paths, and surfaces warnings for unknown fields. Remaining: tighten diagnostics/copy and example hints on errors.
   - Outcome: Readable config defines VMs/resources; auto-discovered from project root with clear diagnostics.

5) VM images and storage hygiene
   - Tension: Need safe image/overlay flows.
   - Outcome: Base images + ephemeral overlays by default; explicit cleanup commands.

6) Networking and connectivity ergonomics
   - Tension: Need predictable host/guest connectivity; first-pass `ports` view exists and detects conflicts and broker overlap. Remaining: integrate live/active state once VMs run.
   - Outcome: NAT with stable forwards; clear `ports` view; common host OSes work.

7) Observability and status legibility
   - Tension: Status/logs surfaces are NYI; copy and states TBD.
   - Outcome: `status`/`logs` provide clear, color-coded info.

8) Safety and resource limits
   - Tension: Preflight checks and limits not implemented.
   - Outcome: Configurable CPU/mem; preflight; graceful shutdown.

9) Toolchain baseline and distribution
   - Tension: Toolchain packaging and releases TBD.
   - Outcome: Stable toolchain target; `cargo install`/releases; `--version` surfaced (commit optional).

Direction of travel
- Build on the working CLI and config/ports flow: deliver a minimal end-to-end run (single VM): up → status → down. Keep UX copy crisp and errors actionable. With the long_about/NYI hint references fixed, next tighten per-command help text and exit code consistency. Coordinate QEMU lifecycle with preflight checks (QEMU presence, overlays, port conflicts).